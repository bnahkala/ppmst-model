# BRADY NAHKALA
# LAST REVISED: 1 JUL 2020

# PURPOSE AND NOTES: =============================================== 
# The initial testing for random forest classification of 
# AnnAGNPS simulated output is included in rndFor_test.R
# and rndFor.R within this project. The input/output data 
# generated for the initial testing of this overall process 
# was done using data_for_Rf_MethodX.R within this project.
# 
# This script attempts to combine the data generation script and 
# random forest training script into a seemless program that 
# builds upon the two. This script will include data generation and 
# random forest training with the additional ability to classify the 
# uncertainty of the random Forest mechanism, with regards to:
#   the subsampling leading to the training dataset
#   the input parameters for the rF algorithm (mtry, ntree, maxnodes)
# 
# This script also included my first testing of randomForestExplainer
# This package helps show how frequently inputs are used and when they
# are the principal (first) node in each tree (e.g. distribution of 
# minimal depth, in their terms)
# 
# Finally, to better understand the structure of trees generated by
# the randomForest package, the reprtree package from github was 
# stripped manually and the functions were imported directly into the RStudio
# workspace. These functions in the files 'plot.getTree', 'plot.reprtree',
# 'ReprTree', and 'functions' plot the actual tree structure with variables labeled
# at each node, included the decision made at each node. This package was developed 
# initially with a medical application, which included a methodology for plotting 
# a 'representative tree' of the forest.

# On 3.19.2020 I begin regenerating random forest data after having rerun
# most of the annagnps models, including recalibrating cardinal and mouth, 
# and adding 4 new scenarios (19-23)
# 
# On 4.7.2020 I began regenerating random mforest data after adding scenarios 
# 22-38

# On 4.17.2020 I limited the random forest model to just the scenario matrix, not all
# redundant scenarios

# On 6.11.2020 I updated the weighting ranks based on feedback from Andy Vanloocke and
# switched the maximum flow length to the maximum reach network length from annagnps, 
# not gis, which seemed deflated based on the length of the watershed

# ===== 

# on 7.1.2020 I changed the default field cover for mouth from CSEXP to CS

# LIBRARY =====================
library(dplyr)
library(tidyr)
library(randomForest)
library(randomForestExplainer)
library(tree)
library(plotrix)
library(cluster)
library(factoextra)
library(BAMMtools)
library(ggpubr)
library(gridExtra)
library(data.tree)
#library(reprtree) - needed to manually download package code

# DATA IMPORT ======================================================
data.bunny.df <- read.table("Bunny_Output_TEST_headers.csv", header=TRUE, sep=",")
data.walnut.df <- read.table("Walnut_Output_TEST_headers.csv", header=TRUE, sep=",")
data.lettuce.df <- read.table("Lettuce_Output_TEST_headers.csv", header=TRUE, sep=",")
data.cardinal.df <- read.table("Cardinal_Output_TEST_headers.csv", header=TRUE, sep=",")
data.mouth.df <- read.table("Mouth_Output_TEST_headers.csv", header=TRUE, sep=",")
data.hen.df <- read.table("HenPlume_Output_TEST_headers.csv", header=TRUE, sep=",")


# these are the characteristics of each pothole based on GIS analysis
# and field observation for their base condition. Assumed the metric system. 
chars.potholes <- data.frame("pothole" = c("Bunny", "Walnut", "Lettuce", "Cardinal", "Hen", "Mouth"), 
                             "ca.sa.ratio" = c(7.5, 3.7, 6.3, 8.7, 6.9, 10.2),
                             "max.h2oshed.relief" = c(6.1, 4.43, 5.39, 5.489, 4.48, 5.624),
                             "max.flow.path" = c(458.83, 322.141, 276.856, 240.872, 152.666, 142.109),
                             "max.flow.annagnps" = c(902.7, 297.7, 239.8, 537.1, 229.8, 350.3),
                             "depth.max" = c(1.0, 0.7, 0.8, 0.7, 0.5, 0.4),
                             "area.max" = c(5.35, 2.6, 2.11, 1.49, 0.51, 0.94),
                             "vol.max" = c(29356, 11838, 8274, 5832, 1766, 1136),
                             "drainage.status" = c("high", "medium", "low", "medium", "none", "none"), 
                             "pothole.cover" = c("CS", "CS", "CS", "CS", "CS", "R"),
                             "field.cover" = c(rep("CS", 6)),
                             "tillage" = c(rep("conventional")))

# these are the characteristics of each simulated scenario in AnnAGNPS
# those written as "base" are later replaced based on the base condition
# for each pothole, which is why they are not given in this dataset
chars.scenarios <- data.frame("scenario" = c("Base", "RetiredAll", "ConTill", "RetiredPothole", "Drain1", "Drain2", "Drain3",
                                             "PlantDate1", "PlantDate2", "PlantDate3", "PlantDate4", "NoTill", "ConTillRetired",
                                             "NoTillRetired", "ConTillDrain1", "ConTillDrain2", "ConTillDrain3", "CoverCrop", 
                                             "BaseRetired", "Drain1Retired", "Drain2Retired", "Drain3Retired", "Drain0", "Drain0CT", 
                                             "Drain0NT", "Drain1NT", "Drain2NT", "Drain3NT", "BaseRetiredCT", "Drain1RetiredCT", 
                                             "Drain2RetiredCT", "Drain3RetiredCT", "BaseRetiredNT", "Drain1RetiredNT", "Drain2RetiredNT",
                                             "Drain3RetiredNT", "Drain1RetiredAll", "Drain2RetiredAll", "Drain3RetiredAll"),
                              "drainage.status" = c("base", "none", "base","none", "low", "medium", "high", "base", "base", "base",
                                                    "base", "base", "none", "none", "low", "medium", "high", "base", "base", 
                                                    "low", "medium", "high", "none", "none", "none", "low", "medium", "high", "base",
                                                    "low", "medium", "high", "base", "low", "medium", "high", "low", "medium", "high"), 
                              "pothole.cover" = c("base", "R", "base", "R", rep("CS", 3), rep("base", 5), rep("R", 2), rep("CS", 3), "base",
                                                  rep("R", 4), rep("CS", 6), "base", rep("R", 10)),
                              "field.cover" = c("base", "R", rep("base", 15), "CC", rep("base", 4), rep("CS", 6), rep("R", 11)),
                              "tillage" = c("base", "N/A", "contill", rep("base", 8), "notill", "contill", "notill", rep("contill", 3),
                                            "notill", rep("base", 4), "conventional", "contill", rep("notill", 4), rep("contill", 4), 
                                            rep("notill", 4), rep("N/A", 3)))

simulation_numbers <- data.frame("Drain0" = c(22, 23, 24, 3, 12, 13, 1),
                                 "Drain1" = c(4, 14, 25, 19, 29, 33, 36),
                                 "Drain2" = c(5, 15, 26, 20, 30, 34, 37),
                                 "Drain3" = c(6, 16, 27, 21, 31, 35, 38))
simulation_numbers2 <- data.frame("CSCV" = c(22, 4, 5, 6),
                                  "CSCT" = c(23, 14, 15, 16),
                                  "CSNT" = c(24, 25, 26, 27),
                                  "RCV" = c(3, 19, 20, 21),
                                  "RCT" = c(12, 29, 30, 31),
                                  "RNT" = c(13, 33, 34, 35),
                                  "RR" = c(1, 36, 37, 38))

simulation_numbers3 <- data.frame("PDCC" = c(0, 7, 8, 9, 10, 17))

simulation_shortIDs <- data.frame("Drain0" = c("D0-CS-CV", "D0-CS-CT", "D0-CS-NT", "D0-R-CV", "D0-R-CT", "D0-R-NT","D0-R-R"),
                                  "Drain1" = c("D1-CS-CV", "D1-CS-CT", "D1-CS-NT", "D1-R-CV", "D1-R-CT", "D1-R-NT","D1-R-R"),
                                  "Drain2" = c("D2-CS-CV", "D2-CS-CT", "D2-CS-NT", "D2-R-CV", "D2-R-CT", "D2-R-NT","D2-R-R"),
                                  "Drain3" = c("D3-CS-CV", "D3-CS-CT", "D3-CS-NT", "D3-R-CV", "D3-R-CT", "D3-R-NT","D3-R-R"))
simulation_shortIDs2 <- data.frame("CSCV" = c("D0-CS-CV", "D1-CS-CV", "D2-CS-CV", "D3-CS-CV"),
                                   "CSCT" = c("D0-CS-CT", "D1-CS-CT", "D2-CS-CT", "D3-CS-CT"),
                                   "CSNT" = c("D0-CS-NT", "D1-CS-NT", "D2-CS-NT", "D3-CS-NT"),
                                   "RCV" = c("D0-R-CV", "D1-R-CV", "D2-R-CV", "D3-R-CV"),
                                   "RCT" = c("D0-R-CT", "D1-R-CT", "D2-R-CT", "D3-R-CT"),
                                   "RNT" = c("D0-R-NT", "D1-R-NT", "D2-R-NT", "D3-R-NT"),
                                   "RR" = c("D0-R-R", "D1-R-R", "D2-R-R", "D3-R-R"))
simulation_shortIDs3 <- data.frame("PDCC" = c("DX-X-CV","PD-2E", "PD-2L", "PD-4L", "PD-6L", "DX-CC-NT"))

simulation_names <- data.frame("Drain0" = c("Drain0", "Drain0CT", "Drain0NT", "RetiredPothole", "ConTillRetired", "NoTillRetired","RetiredAll"),
                               "Drain1" = c("Drain1", "ConTillDrain1", "Drain1NT", "Drain1Retired", "Drain1RetiredCT", "Drain1RetiredNT","Drain1RetiredAll"),
                               "Drain2" = c("Drain2", "ConTillDrain2", "Drain2NT", "Drain2Retired", "Drain2RetiredCT", "Drain2RetiredNT","Drain2RetiredAll"),
                               "Drain3" = c("Drain3", "ConTillDrain3", "Drain3NT", "Drain3Retired", "Drain3RetiredCT", "Drain3RetiredNT","Drain3RetiredAll"))

simulation_names2 <- data.frame("CSCV" = c("Drain0", "Drain1", "Drain02", "Drain03"),
                                "CSCT" = c("Drain0CT", "ConTillDrain01", "ConTillDrain02", "ConTillDrain03"),
                                "CSNT" = c("Drain0NT", "Drain1NT", "Drain2NT", "Drain3NT"),
                                "RCV" = c("RetiredPothole", "Drain1Retired", "Drain2Retired", "Drain3Retired"),
                                "RCT" = c("ConTillRetired", "Drain1RetiredCT", "Drain2RetiredCT", "Drain3RetiredCT"),
                                "RNT" = c("NoTillRetired", "Drain1RetiredNT", "Drain2RetiredNT", "Drain3RetiredNT"),
                                "RR" = c("RetiredAll", "Drain1RetiredAll", "Drain2RetiredAll", "Drain3RetiredAll"))
simulation_names3 <- data.frame("PDCC" = c("PlantDate1", "PlantDate2", "PlantDate3", "PlantDate4", "CoverCrop"))

sim_nms <- simulation_names %>%
  gather() %>%
  rbind(gather(simulation_names3))

sim_nms2 <- simulation_names %>%
  gather()

# RESHAPE ==========================================================
# function for tidying up data; it reduces the width and lengthens the dataset
# which is an incredibly useful format to work with. It is gathered by the groups
# year, month, day, and pothole, where the observation is now only volume
aggregate.raw.data <- function(data.df, name) {
  data.reshape.df <- data.df %>%
    gather(key=scen, value=volume, -c(Gregorian, Year, Month, Day)) %>%
    mutate(Pothole=c(rep(name,1)))
  return(data.reshape.df)
}

# execute the above function
data.bunny.reshape.df <- aggregate.raw.data(data.bunny.df, "bunny")
data.walnut.reshape.df <- aggregate.raw.data(data.walnut.df, "walnut")
data.lettuce.reshape.df <- aggregate.raw.data(data.lettuce.df, "lettuce")
data.cardinal.reshape.df <- aggregate.raw.data(data.cardinal.df, "cardinal")
data.hen.reshape.df <- aggregate.raw.data(data.hen.df, "hen")
data.mouth.reshape.df <- aggregate.raw.data(data.mouth.df, "mouth")

# combine data from all potholes, scenarios
data.reshape.all.df <- rbind(data.bunny.reshape.df, data.walnut.reshape.df, data.lettuce.reshape.df, data.cardinal.reshape.df, 
                             data.hen.reshape.df, data.mouth.reshape.df)

# filter, include only days with ponded water
data.filter.all.df <- data.reshape.all.df %>%
  filter(volume >0, scen != "wetness")

# clean up
rm(data.bunny.reshape.df, data.walnut.reshape.df, data.lettuce.reshape.df, data.cardinal.reshape.df, data.hen.reshape.df,
   data.mouth.reshape.df)
# clean up some of the intermediate data forms
rm(data.bunny.df, data.walnut.df, data.lettuce.df, data.cardinal.df, data.hen.df, data.mouth.df)

# SUPPORT DATA =====================================================

# create a database of each event from all 108 simulations (next 70 lines)
event.database.df <- data.frame(Gregorian.start=integer(50000),
                                Year.start=integer(50000),
                                Month.start=integer(50000),
                                Day.start=integer(50000),
                                scen=character(50000),
                                Pothole=character(50000),
                                Event.length=integer(50000),
                                Event.max.vol=numeric(50000),
                                Event.max.date=integer(50000), 
                                stringsAsFactors = FALSE) # to help write character strings

# start loop counters
rw <-1
r <- 1
# must use a while loop, not a for loop for uneven step sizes
while (r >= 1 & r <= length(data.filter.all.df$Gregorian)){
  # record start of event
  event.database.df$Gregorian.start[rw] = data.filter.all.df$Gregorian[r]
  event.database.df$Year.start[rw] = data.filter.all.df$Year[r]
  event.database.df$Month.start[rw] = data.filter.all.df$Month[r]
  event.database.df$Day.start[rw] = data.filter.all.df$Day[r]
  event.database.df$scen[rw] = data.filter.all.df$scen[r]
  event.database.df$Pothole[rw] = data.filter.all.df$Pothole[r]
  
  # initialize event details (length, mx volume, date in event of mx volume)
  l <- 1
  mx <- data.filter.all.df$volume[r]
  mx.dt <- 1
  
  # checking other days in the event
  # equal to r becuase r is not incremented by the same value every time
  rww <-r
  # for consecutive days in the record, keep track of the event details 
  # in this loop
  while ((data.filter.all.df[rww+1,1] - data.filter.all.df[rww,1]) == 1) {
    # increment the length of the event
    l <- l+1
    # check in for maximum volume, record what day of the event it was
    if (data.filter.all.df$volume[rww+1] > data.filter.all.df$volume[rww]){
      mx <- data.filter.all.df$volume[rww]
      mx.dt <- mx.dt + 1
    }
    # step the event reading row counter
    rww <- rww + 1
  }
  
  # write event details
  event.database.df$Event.length[rw] = l
  event.database.df$Event.max.vol[rw] = mx
  event.database.df$Event.max.date[rw] = mx.dt
  
  # step event database row counter
  rw <- rw+1
  
  # step the inundated days reading counter
  r <- r+(l)
}

# POST PROCESS ERROR CORRECTION
# get rid of empty rows at end of data frame
event.database.df <- event.database.df %>%
  filter(Gregorian.start > 0)

# fill in last three values. I have no idea why they didn't write within the loop
event.database.df$Event.length[length(event.database.df$Event.length)] = l
event.database.df$Event.max.vol[length(event.database.df$Event.length)] = mx
event.database.df$Event.max.date[length(event.database.df$Event.length)] = mx.dt

# cleanup
rm(l, mx, mx.dt, r, rw, rww)

# RANKING SYSTEM ===================================================

# calculate the percentage of events in each bin by Pothole, scenario 
event.database.pct.df <- event.database.df[, c(2, 5:7)] %>%
  group_by(scen, Pothole) %>% #month 
  summarise(Pct.one = sum(Event.length == 1)/ n(),
            Pct.two = sum(Event.length == 2)/ n(),
            Pct.three = sum(Event.length == 3)/ n(),
            Pct.four = sum(Event.length == 4)/ n(),
            Pct.five = sum(Event.length == 5)/ n(),
            Pct.six = sum(Event.length == 6)/ n(),
            Pct.seven = sum(Event.length == 7)/ n(),
            Pct.eight = sum(Event.length == 8)/ n(),
            Pct.nine = sum(Event.length == 9)/ n(),
            Pct.tenplus = sum(Event.length >= 10)/ n(),
  ) %>%
  gather(key="Bin", value="Pct", -c(scen, Pothole)) %>% # shrink the data frame
  complete(scen, Pothole, Bin, 
           fill=list(Pct=0)) %>%                        # fill in the missing data combinations
  distinct() %>%                                        # remove duplicates
  spread(key="Bin", value="Pct")                        # reshape to match future sampling scheme

# calculate percent of each month that is inundated 
pct.month.inundated.df <- data.filter.all.df[ , c(2:3, 5:7)] %>%
  group_by(Month, scen, Pothole) %>%
  summarize(n=n()) %>%                                  # only counts within the group structure specified
  complete(scen, Pothole, Month=1:12, 
           fill=list(n=0)) %>%
  distinct()

# convert to average % across 25 years of simulation, based on different month lenghts 
for (x in 1:length(pct.month.inundated.df$scen)){
  if (pct.month.inundated.df$Month[x] == 4 | pct.month.inundated.df$Month[x] == 6 | pct.month.inundated.df$Month[x] == 9 |
      pct.month.inundated.df$Month[x] == 11) {
    pct.month.inundated.df$n[x] <- pct.month.inundated.df$n[x] / (30 *25)
  } else if (pct.month.inundated.df$Month[x] == 2) {
    pct.month.inundated.df$n[x] <- pct.month.inundated.df$n[x] / (28*25)
  } else {
    pct.month.inundated.df$n[x] <- pct.month.inundated.df$n[x] / (31*25)
  }
}

# widen dataset to view months in columns
pct.month.inundated.df <- pct.month.inundated.df %>%
  spread(key="Month", value="n")

# percent pothole area/volume flooded at certain time points
avg.max.event.flood.pct.by.month.df <- event.database.df[ , c(2:3, 5:8)] %>%
  group_by(Month.start, scen, Pothole) %>%
  summarize(max.ev.by.mo = max(Event.length), 
            max.pct.vol.mo = max(Event.max.vol)) %>%
  complete(Month.start=1:12 ,scen, Pothole, 
           fill=list(max.ev.by.mo=0, max.pct.vol.mo=0)) %>%
  distinct()

# modify the volume to percent of pothole's maximum volume (standard percentage scheme to acct for pothole size)
for (x in 1:length(avg.max.event.flood.pct.by.month.df$Month.start)) {
  if ((avg.max.event.flood.pct.by.month.df$Pothole[x]) == "bunny") {
    avg.max.event.flood.pct.by.month.df$max.pct.vol.mo[x] <- avg.max.event.flood.pct.by.month.df$max.pct.vol.mo[x]/ chars.potholes$vol.max[1]
  } else if ((avg.max.event.flood.pct.by.month.df$Pothole[x]) == "walnut") {
    avg.max.event.flood.pct.by.month.df$max.pct.vol.mo[x] <- avg.max.event.flood.pct.by.month.df$max.pct.vol.mo[x]/ chars.potholes$vol.max[2]
  } else if ((avg.max.event.flood.pct.by.month.df$Pothole[x]) == "lettuce") {
    avg.max.event.flood.pct.by.month.df$max.pct.vol.mo[x] <- avg.max.event.flood.pct.by.month.df$max.pct.vol.mo[x]/ chars.potholes$vol.max[3]
  } else if ((avg.max.event.flood.pct.by.month.df$Pothole[x]) == "cardinal") {
    avg.max.event.flood.pct.by.month.df$max.pct.vol.mo[x] <- avg.max.event.flood.pct.by.month.df$max.pct.vol.mo[x]/ chars.potholes$vol.max[4]
  } else if ((avg.max.event.flood.pct.by.month.df$Pothole[x]) == "hen") {
    avg.max.event.flood.pct.by.month.df$max.pct.vol.mo[x] <- avg.max.event.flood.pct.by.month.df$max.pct.vol.mo[x]/ chars.potholes$vol.max[5]
  } else if ((avg.max.event.flood.pct.by.month.df$Pothole[x]) == "mouth") {
    avg.max.event.flood.pct.by.month.df$max.pct.vol.mo[x] <- avg.max.event.flood.pct.by.month.df$max.pct.vol.mo[x]/ chars.potholes$vol.max[6]
  } else {
    avg.max.event.flood.pct.by.month.df$max.pct.vol.mo[x] <- 0
  }
}  

# create subset of ranking data
max.event.by.month.df <- avg.max.event.flood.pct.by.month.df[ , 1:4] %>%
  spread(key="Month.start", value="max.ev.by.mo") 

# create subset of ranking data
max.pct.vol.by.month.df <- avg.max.event.flood.pct.by.month.df[ ,c(1:3, 5)] %>%
  spread(key="Month.start", value="max.pct.vol.mo")

# clean up
rm(avg.max.event.flood.pct.by.month.df)


# ASSIGN RANKINGS 
# data frames: event.database.pct.df; pct.month.inundated.df; max.event.by.month.df; max.pct.vol.by.month.df
# w1.equal <- 1/10
# w23.equal <- 1/12
# weight1 <- data.frame("event.length" = c(1:10),
#                       "weight" = c(rep(w1.equal, 10)))
# weight2 <- data.frame("month" = c(1:12),
#                       "weight" = c(rep(w23.equal, 12)))
# weight3 <- data.frame("month" = c(1:12),
#                       "weight" = c(rep(w23.equal, 12)))


weight1 <- data.frame("event.length" = c(1:10),
                      "weight" = c(0, 1/24, 2/24, rep(1/8, 7)))
weight2 <- data.frame("month" = c(1:12),
                      "weight" = c(.02, .02, .02, .05, .2, 0.15, .08, .08, 0.15, 0.15, .06, .02))
weight3 <- data.frame("month" = c(1:12),
                      "weight" = c(.02, .02, .02, .1, .2, 0.15, .05, .06, 0.1, 0.2, .06, .02))

# assign rank for pct of length of events
# multiplies the percentage of the events in a bin by the importance of the bin
event.database.pct.df$rank <- numeric(length(event.database.pct.df$scen))
for (x in 1:length(event.database.pct.df$scen)) {
  event.database.pct.df$rank[x] <- event.database.pct.df[x, 4-1] * weight1$weight[8] + 
    event.database.pct.df[x, 5-1] * weight1$weight[5] +
    event.database.pct.df[x, 6-1] * weight1$weight[4] +
    event.database.pct.df[x, 7-1] * weight1$weight[9] +
    event.database.pct.df[x, 8-1] * weight1$weight[1] +
    event.database.pct.df[x, 9-1] * weight1$weight[7] +
    event.database.pct.df[x, 10-1] * weight1$weight[6] +
    event.database.pct.df[x, 11-1] * weight1$weight[10] +
    event.database.pct.df[x, 12-1] * weight1$weight[3] +
    event.database.pct.df[x, 13-1] * weight1$weight[2] 
}

# assign rank for max pct of the volume inundated
# multiplies the percentage of the pothole volume by the importance of the month in which it occurs
max.pct.vol.by.month.df$rank <- numeric(length(max.pct.vol.by.month.df$scen))
for (x in 1:length(max.pct.vol.by.month.df$scen)) {
  max.pct.vol.by.month.df$rank[x] <- max.pct.vol.by.month.df[x, 4-1] * weight2$weight[1] + 
    max.pct.vol.by.month.df[x, 5-1] * weight2$weight[2] +
    max.pct.vol.by.month.df[x, 6-1] * weight2$weight[3] +
    max.pct.vol.by.month.df[x, 7-1] * weight2$weight[4] +
    max.pct.vol.by.month.df[x, 8-1] * weight2$weight[5] +
    max.pct.vol.by.month.df[x, 9-1] * weight2$weight[6] +
    max.pct.vol.by.month.df[x, 10-1] * weight2$weight[7] +
    max.pct.vol.by.month.df[x, 11-1] * weight2$weight[8] +
    max.pct.vol.by.month.df[x, 12-1] * weight2$weight[9] +
    max.pct.vol.by.month.df[x, 13-1] * weight2$weight[10] +
    max.pct.vol.by.month.df[x, 14-1] * weight2$weight[11] +
    max.pct.vol.by.month.df[x, 15-1] * weight2$weight[12] 
}

# assign rank for pct of the month inundated
# multiplies the percentage of the month inundated by the importance of the month 
pct.month.inundated.df$rank <- numeric(length(pct.month.inundated.df$scen))
for (x in 1:length(pct.month.inundated.df$scen)) {
  pct.month.inundated.df$rank[x] <- pct.month.inundated.df[x, 4-1] * weight3$weight[1] + 
    pct.month.inundated.df[x, 5-1] * weight3$weight[2] +
    pct.month.inundated.df[x, 6-1] * weight3$weight[3] +
    pct.month.inundated.df[x, 7-1] * weight3$weight[4] +
    pct.month.inundated.df[x, 8-1] * weight3$weight[5] +
    pct.month.inundated.df[x, 9-1] * weight3$weight[6] +
    pct.month.inundated.df[x, 10-1] * weight3$weight[7] +
    pct.month.inundated.df[x, 11-1] * weight3$weight[8] +
    pct.month.inundated.df[x, 12-1] * weight3$weight[9] +
    pct.month.inundated.df[x, 13-1] * weight3$weight[10] +
    pct.month.inundated.df[x, 14-1] * weight3$weight[11] +
    pct.month.inundated.df[x, 15-1] * weight3$weight[12] 
}

ranked.method <- pct.month.inundated.df[ , 1:2] %>%
  arrange(scen) %>%
  #arrange(Year) %>%
  arrange(Pothole)

rank1 <- event.database.pct.df[ , c(1:2, 13)] %>%
  arrange(scen) %>%
  #arrange(Year.start) %>%
  arrange(Pothole)

rank2 <- max.pct.vol.by.month.df[ , c(1:2, 15)] %>%
  arrange(scen) %>%
  #arrange(Year.start) %>%
  arrange(Pothole)

rank3 <- pct.month.inundated.df[ , c(1:2, 15)] %>%
  arrange(scen) %>%
  #arrange(Year) %>%
  arrange(Pothole)

ranked.method$rank1 <- rank1$rank
ranked.method$rank2 <- rank2$rank
ranked.method$rank3 <- rank3$rank

ranked.method[ , 3:5] <- sapply(ranked.method[ , 3:5], as.numeric)
ranked.method$rank1 <- ranked.method$rank1 / max(ranked.method$rank1)
ranked.method$rank2 <- ranked.method$rank2 / max(ranked.method$rank2)
ranked.method$rank3 <- ranked.method$rank3 / max(ranked.method$rank3)

ranked.method$rankm <- as.numeric(ranked.method$rank1) * as.numeric(ranked.method$rank2) * as.numeric(ranked.method$rank3)
ranked.method <- as.data.frame(ranked.method) %>%
  mutate(rankm.base10 = rankm / (max(rankm) / (10))) %>%
  within(rm(rankm))
ranked.method <-  rename(ranked.method, rankm = rankm.base10)
# ranked.method$ranka <- as.numeric(ranked.method$rank1) + as.numeric(ranked.method$rank2) + as.numeric(ranked.method$rank3)

# cleanup
rm(rank1, rank2, rank3)
rm(weight1, weight2, weight3)
rm(data.filter.all.df, data.reshape.all.df, event.database.df)

# FINALIZE TRAINING DATA ===========================================

# CREATE TRAINING SET FUNCTION 
# create function for generating input data to random forest algorithm
# modified to not use numerical data
# modified to not split samples by year as well
create.training.set <- function (ranked.data.df){ 
  
  # drainage status
  ranked.data.df$Drainage <- character(length(ranked.data.df$scen))
  # current till
  ranked.data.df$Tillage <- character(length(ranked.data.df$scen))
  # LULC
  ranked.data.df$lulc.pothole <- character(length(ranked.data.df$scen))
  ranked.data.df$lulc.field <- character(length(ranked.data.df$scen))
  # catchment-area to pothole-area ratio
  ranked.data.df$capa.ratio <- numeric(length(ranked.data.df$scen))
  # maximum change in elevation for the microwatershed, m
  ranked.data.df$max.h2oshed.relief <- numeric(length(ranked.data.df$scen))
  # longest flow path
  ranked.data.df$max.flow.path <- numeric(length(ranked.data.df$scen))
  # maximum pothole depth, m
  ranked.data.df$max.depth <- numeric(length(ranked.data.df$scen))
  
  
  # fix naming discontinuity
  for (x in 1:length(ranked.data.df$scen)) {
    if (as.character(ranked.data.df$scen[x]) == "PlantDate01") {
      ranked.data.df$scen[x] <- "PlantDate1"
    } else {
    }
    if (as.character(ranked.data.df$scen[x]) == "PlantDate02") {
      ranked.data.df$scen[x] <- "PlantDate2"
    } else {
    }
    if (as.character(ranked.data.df$scen[x]) == "PlantDate03") {
      ranked.data.df$scen[x] <- "PlantDate3"
    } else {
    }
    if (as.character(ranked.data.df$scen[x]) == "PlantDate04") {
      ranked.data.df$scen[x] <- "PlantDate4"
    } else {
    }
    if (as.character(ranked.data.df$scen[x]) == "Drain01") {
      ranked.data.df$scen[x] <- "Drain1"
    } else {
    }
    if (as.character(ranked.data.df$scen[x]) == "Drain02") {
      ranked.data.df$scen[x] <- "Drain2"
    } else {
    }
    if (as.character(ranked.data.df$scen[x]) == "Drain03") {
      ranked.data.df$scen[x] <- "Drain3"
    } else {
    }
    
    if (as.character(ranked.data.df$scen[x]) == "ConTillDrain01") {
      ranked.data.df$scen[x] <- "ConTillDrain1"
    } else {
    }
    if (as.character(ranked.data.df$scen[x]) == "ConTillDrain02") {
      ranked.data.df$scen[x] <- "ConTillDrain2"
    } else {
    }
    if (as.character(ranked.data.df$scen[x]) == "ConTillDrain03") {
      ranked.data.df$scen[x] <- "ConTillDrain3"
    } else {
    }
  }
  
  # fill by scenario information
  for (x in 1:length(ranked.data.df$scen)) {
    for (y in 1:39) {
      if (as.character(ranked.data.df$scen[x]) == as.character(chars.scenarios$scenario[y])) {
        ranked.data.df$Drainage[x] <- as.character(chars.scenarios$drainage.status[y])
        ranked.data.df$Tillage[x] <- as.character(chars.scenarios$tillage[y])
        ranked.data.df$lulc.pothole[x] <- as.character(chars.scenarios$pothole.cover[y])
        ranked.data.df$lulc.field[x] <- as.character(chars.scenarios$field.cover[y])
      } else {
      }
    }
  }
  
  # apply conventional tillage to all
  for (x in 1:length(ranked.data.df$scen)) {
    if (ranked.data.df$Tillage[x] == "base") {
      ranked.data.df$Tillage[x] <- "conventional"
    }
  }
  
  # apply pothole management
  for (x in 1:length(ranked.data.df$scen)) {
    if (ranked.data.df$Pothole[x] != "mouth" & ranked.data.df$lulc.pothole[x] == "base") {
      ranked.data.df$lulc.pothole[x] <- "CS"
    } else if (ranked.data.df$Pothole[x] == "mouth" & ranked.data.df$lulc.pothole[x] == "base"){
      ranked.data.df$lulc.pothole[x] <- "R"
    } else {
      
    }
  }
  
  # fill empty data vectors
  for (x in 1:length(ranked.data.df$scen)) {
    if ((ranked.data.df$Pothole[x]) == "bunny" & (ranked.data.df$Drainage[x]) == "base") {
      ranked.data.df$Drainage[x] <- "high"
    } else if ((ranked.data.df$Pothole[x]) == "walnut" & (ranked.data.df$Drainage[x]) == "base") {
      ranked.data.df$Drainage[x] <- "medium"
    } else if ((ranked.data.df$Pothole[x]) == "lettuce" & (ranked.data.df$Drainage[x]) == "base") {
      ranked.data.df$Drainage[x] <- "low"
    }else if ((ranked.data.df$Pothole[x]) == "cardinal" & (ranked.data.df$Drainage[x]) == "base") {
      ranked.data.df$Drainage[x] <- "medium"
    }else if ((ranked.data.df$Pothole[x]) == "hen" & (ranked.data.df$Drainage[x]) == "base") {
      ranked.data.df$Drainage[x] <- "none"
    }else if ((ranked.data.df$Pothole[x]) == "mouth" & (ranked.data.df$Drainage[x]) == "base") {
      ranked.data.df$Drainage[x] <- "none"
    }else {
      #ranked.data.df$Drainage[x] <- "na"
    }
  }
  
  # fill empty data vectors
  for (x in 1:length(ranked.data.df$scen)) {
    if (as.character(ranked.data.df$Pothole[x]) == "bunny" & as.character(ranked.data.df$lulc.pothole[x]) == "base") {
      ranked.data.df$capa.ratio[x] <- chars.potholes$ca.sa.ratio[1]
      ranked.data.df$Drainage[x] <- "high"
      ranked.data.df$lulc.pothole <- "CS"
    } else if (as.character(ranked.data.df$Pothole[x]) == "walnut" & as.character(ranked.data.df$lulc.pothole[x]) == "base") {
      ranked.data.df$capa.ratio[x] <- chars.potholes$ca.sa.ratio[2]
      ranked.data.df$Drainage[x] <- "medium"
      ranked.data.df$lulc.pothole <- "CS"
    } else if (as.character(ranked.data.df$Pothole[x]) == "lettuce" & as.character(ranked.data.df$lulc.pothole[x]) == "base") {
      ranked.data.df$capa.ratio[x] <- chars.potholes$ca.sa.ratio[3]
      ranked.data.df$Drainage[x] <- "low"
      ranked.data.df$lulc.pothole <- "CS"
    }else if (as.character(ranked.data.df$Pothole[x]) == "cardinal" & as.character(ranked.data.df$lulc.pothole[x]) == "base") {
      ranked.data.df$capa.ratio[x] <- chars.potholes$ca.sa.ratio[4]
      ranked.data.df$Drainage[x] <- "medium"
      ranked.data.df$lulc.pothole <- "CS"
    }else if (as.character(ranked.data.df$Pothole[x]) == "hen" & as.character(ranked.data.df$lulc.pothole[x]) == "base") {
      ranked.data.df$capa.ratio[x] <- chars.potholes$ca.sa.ratio[5]
      ranked.data.df$Drainage[x] <- "none"
      ranked.data.df$lulc.pothole <- "CS"
    }else if (as.character(ranked.data.df$Pothole[x]) == "mouth" & as.character(ranked.data.df$lulc.pothole[x]) == "base") {
      ranked.data.df$capa.ratio[x] <- chars.potholes$ca.sa.ratio[6]
      ranked.data.df$Drainage[x] <- "none"
      ranked.data.df$lulc.pothole <- "R"
    }else {
      #ranked.data.df$capa.ratio[x] <- 0
    }
  }
  
  
  for (x in 1:length(ranked.data.df$scen)) {
    if (as.character(ranked.data.df$Pothole[x]) == "bunny") {
      ranked.data.df$capa.ratio[x] <- chars.potholes$ca.sa.ratio[1]
      ranked.data.df$max.h2oshed.relief[x] <- chars.potholes$max.h2oshed.relief[1]
      ranked.data.df$max.depth[x] <- chars.potholes$depth.max[1]
      ranked.data.df$max.flow.path[x] <- chars.potholes$max.flow.annagnps[1]
    } else if (as.character(ranked.data.df$Pothole[x]) == "walnut") {
      ranked.data.df$capa.ratio[x] <- chars.potholes$ca.sa.ratio[2]
      ranked.data.df$max.h2oshed.relief[x] <- chars.potholes$max.h2oshed.relief[2]
      ranked.data.df$max.depth[x] <- chars.potholes$depth.max[2]
      ranked.data.df$max.flow.path[x] <- chars.potholes$max.flow.annagnps[2]
    } else if (as.character(ranked.data.df$Pothole[x]) == "lettuce") {
      ranked.data.df$capa.ratio[x] <- chars.potholes$ca.sa.ratio[3]
      ranked.data.df$max.h2oshed.relief[x] <- chars.potholes$max.h2oshed.relief[3]
      ranked.data.df$max.depth[x] <- chars.potholes$depth.max[3]
      ranked.data.df$max.flow.path[x] <- chars.potholes$max.flow.annagnps[3]
    } else if (as.character(ranked.data.df$Pothole[x]) == "cardinal") {
      ranked.data.df$capa.ratio[x] <- chars.potholes$ca.sa.ratio[4]
      ranked.data.df$max.h2oshed.relief[x] <- chars.potholes$max.h2oshed.relief[4]
      ranked.data.df$max.depth[x] <- chars.potholes$depth.max[4]
      ranked.data.df$max.flow.path[x] <- chars.potholes$max.flow.annagnps[4]
    } else if (as.character(ranked.data.df$Pothole[x]) == "hen") {
      ranked.data.df$capa.ratio[x] <- chars.potholes$ca.sa.ratio[5]
      ranked.data.df$max.h2oshed.relief[x] <- chars.potholes$max.h2oshed.relief[5]
      ranked.data.df$max.depth[x] <- chars.potholes$depth.max[5]
      ranked.data.df$max.flow.path[x] <- chars.potholes$max.flow.annagnps[5]
    } else if (as.character(ranked.data.df$Pothole[x]) == "mouth") {
      ranked.data.df$capa.ratio[x] <- chars.potholes$ca.sa.ratio[6]
      ranked.data.df$max.h2oshed.relief[x] <- chars.potholes$max.h2oshed.relief[6]
      ranked.data.df$max.depth[x] <- chars.potholes$depth.max[6]
      ranked.data.df$max.flow.path[x] <- chars.potholes$max.flow.annagnps[6]
    } else {
      ranked.data.df$capa.ratio[x] <- 0
      ranked.data.df$max.h2oshed.relief[x] <- 0
      ranked.data.df$max.depth[x] <- 0
      ranked.data.df$max.flow.path[x] <- 0
    }
  }
  
  # correction on 1.23.2020 for RetiredAll scenario LULC_field parameters
  for (y in 1:length(ranked.data.df$scen)) {
    if (ranked.data.df$scen[y] == "RetiredAll") {
      ranked.data.df$lulc.field[y] <- "R"
    } else if (ranked.data.df$Pothole[y] == "mouth") {
      ranked.data.df$lulc.field[y] <- "CS"
    } else {
      ranked.data.df$lulc.field[y] <- "CS"
    }
  }
  
  
  return(ranked.data.df)
}

rfTrain <- create.training.set(ranked.method)

# CATEGORICAL CLUSTERING ===========================================
# kmeans using cluster package OR
# Jenks Natural breaks using BAMMtools

kdatm <- as.numeric(unlist(rfTrain[ , 6]))
brksm6 <- getJenksBreaks(kdatm, 7)
brksm3 <- getJenksBreaks(kdatm, 4)
plot(sort(rfTrain$rankm))
abline(h=brksm6)

rfTrain$catm3 <- character(length(rfTrain$rankm))
rfTrain$catm6 <- character(length(rfTrain$rankm))

rfTrain <- within(rfTrain, catm3[between(rankm, brksm3[1], brksm3[2])] <- "c")
rfTrain <- within(rfTrain, catm3[between(rankm, brksm3[2], brksm3[3])] <- "b")
rfTrain <- within(rfTrain, catm3[between(rankm, brksm3[3], brksm3[4])] <- "a")

rfTrain <- within(rfTrain, catm6[between(rankm, brksm6[1], brksm6[2])] <- "f")
rfTrain <- within(rfTrain, catm6[between(rankm, brksm6[2], brksm6[3])] <- "e")
rfTrain <- within(rfTrain, catm6[between(rankm, brksm6[3], brksm6[4])] <- "d")
rfTrain <- within(rfTrain, catm6[between(rankm, brksm6[4], brksm6[5])] <- "c")
rfTrain <- within(rfTrain, catm6[between(rankm, brksm6[5], brksm6[6])] <- "b")
rfTrain <- within(rfTrain, catm6[between(rankm, brksm6[6], brksm6[7])] <- "a")

# rfTrain <- within(rfTrain, remove(catm))

# DATA BACKUP ====================================================== 

rfTrain.w <- rfTrain[ , c(1:2,6:16)]
write.csv(rfTrain.w, "rfTrain_scale.csv")

rm(rfTrain.w)
rm(event.database.pct.df, max.event.by.month.df, max.pct.vol.by.month.df, pct.month.inundated.df)
rm(ranked.method)

# RF DATA IMPORT ===================================================


data.df <- read.csv("rfTrain_scale.csv", header=TRUE, sep = ",")
data.df <- data.df %>%
  filter(scen %in% sim_nms2$value)

# specify training data for two methods
rFdata.m.df <- data.df
rFdata.m.df <- within(data.df, rm(catm3, catm6))
rFdata.cm3.df <- within(data.df, rm(catm6, rankm))
rFdata.cm6.df <- within(data.df, rm(catm3, rankm))

# RF MODELING (REGRESSION) =========================================
rsq <- function(x,y) cor(x,y)^2

# track rsq
pct.var.m <- data.frame(rsq=numeric(1),
                        n=numeric(1),
                        m=numeric(1), 
                        valid.rsq=numeric(1),
                        mse=numeric(1))
                        
m.sensitivity.full <- data.frame(seed=numeric(5400),
                                 mtry=numeric(5400),
                                 ntree=numeric(5400),
                                 avgc=numeric(5400),
                                 stdc=numeric(5400),
                                 avgv=numeric(5400), 
                                 stdv=numeric(5400))

# check the influence of seed, mtry, and ntree on the model
# account for the randomness in rF by running 100x for each param set
# so I didn't really think about this. Loop currently runs ~3-6 hours. 
# see RF MODEL DEVELOPMENT MANAGER
sd <- 1
k <- 1
while (sd < 101) {
  
  set.seed(sd)
  # subsample the training sets for each method
  rows.train.df <- sample(nrow(rFdata.m.df), 0.7*nrow(rFdata.m.df), replace=FALSE) # list of row vals only
  train.m.df <- rFdata.m.df[rows.train.df, ]
  valid.m.df <- rFdata.m.df[-rows.train.df, ]
  
  
  
  
  m=2
  while (m < 8) {
    
    n=500
    while (n < 2200) {
      
      i <- 1
      while (i < 2 ) {
        
        # normal models
        mod.m <- randomForest(rankm ~Drainage+
                                Tillage+
                                lulc.pothole+
                                lulc.field+
                                capa.ratio+
                                max.depth+
                                max.flow.path+
                                max.h2oshed.relief, data = train.m.df, ntree=n, mtry=m, replace=TRUE, importance=TRUE, proximity=TRUE)
        mod.m
        valid.m.df$pred <- predict2.randomForest(mod.m, valid.m.df)
        pred.m.rsq <- rsq(valid.m.df$rankm, valid.m.df$pred)
      
        pct.var.m[i, 1] <- mod.m$rsq[length(mod.m$rsq)]
        pct.var.m[i, 2] <- n
        pct.var.m[i, 3] <- m
        pct.var.m[i, 4] <- pred.m.rsq
        pct.var.m[i, 5] <- mod.m$mse[length(mod.m$mse)]
      
        i = i+1
  
      }
      
      m.sensitivity.full[k, ] <- pct.var.m %>%
        summarize(seed=mean(sd),
                  mtry=mean(m),
                  ntree=mean(n),
                  avgc=mean(rsq),
                  stdc=sd(rsq),
                  avgv=mean(valid.rsq), 
                  stdv=sd(valid.rsq))
      k <- k + 1
      n <- n + 200
      
    }
    m <-  m + 1
  }
  sd = sd + 1
  print(sd)
}

seed.avgs <- m.sensitivity.full %>%
  group_by(seed) %>%
  summarise(avgc = mean(avgc), avgv=mean(avgv))

windows()
plot(seed ~ avgc, data = m.sensitivity.full)

# check influence of limiting the number of terminal nodes
pct.var.mxnd <- data.frame(rsq=numeric(50),
                           n=numeric(50),
                           m=numeric(50),
                           valid.rsq=numeric(50),
                           mse=numeric(50), 
                           mxnd=numeric(50))

# check maximum number of nodes
m <- 6
n <- 500
mxnd <- 5
i <- 1

set.seed(22)
# subsample the training sets for each method
rows.train.df <- sample(nrow(rFdata.m.df), 0.7*nrow(rFdata.m.df), replace=FALSE) # list of row vals only
train.m.df <- rFdata.m.df[rows.train.df, ]
valid.m.df <- rFdata.m.df[-rows.train.df, ]

while (mxnd < 51) {
  
  mod.m <- randomForest(rankm ~Drainage+
                                Tillage+
                                lulc.pothole+
                                lulc.field+
                                capa.ratio+
                                max.depth+
                                max.flow.path+
                                max.h2oshed.relief, data = train.m.df, ntree=n, mtry=m, maxnodes=mxnd, 
                        replace=TRUE, importance=TRUE, proximity=TRUE)
  
  print(mod.m)
  
  valid.m.df$pred <- predict(mod.m, valid.m.df)
  pred.m.rsq <- rsq(valid.m.df$rankm, valid.m.df$pred)
  
  pct.var.mxnd[i, 1] <- mod.m$rsq[length(mod.m$rsq)]
  pct.var.mxnd[i, 2] <- n
  pct.var.mxnd[i, 3] <- m
  pct.var.mxnd[i, 4] <- pred.m.rsq
  pct.var.mxnd[i, 5] <- mod.m$mse[length(mod.m$mse)]
  pct.var.mxnd[i, 6] <- mxnd
    
  mxnd <- mxnd + 1 
  i <- i + 1
}

plot(pct.var.mxnd$mxnd[1:46], pct.var.mxnd$rsq[1:46])
points(pct.var.mxnd$mxnd[1:46], pct.var.mxnd$valid.rsq[1:46], col="red")


# RF MODELING (CATEGORICAL) ======================================

# mod.cm <- randomForest(catm ~., data = train.cm.df, ntree=500, mtry=4, replace=TRUE, importance=TRUE, proximity=TRUE)
# mod.cm

# track error
pct.var.cm3 <- data.frame(err=numeric(1),
                        n=numeric(1),
                        m=numeric(1), 
                        valid.err=numeric(1))

cm3.sensitivity.full <- data.frame(seed=numeric(5400),
                                 mtry=numeric(5400),
                                 ntree=numeric(5400),
                                 avgc=numeric(5400),
                                 stdc=numeric(5400),
                                 avgv=numeric(5400), 
                                 stdv=numeric(5400))

pct.var.cm6 <- data.frame(err=numeric(1),
                          n=numeric(1),
                          m=numeric(1), 
                          valid.err=numeric(1))

cm6.sensitivity.full <- data.frame(seed=numeric(5400),
                                   mtry=numeric(5400),
                                   ntree=numeric(5400),
                                   avgc=numeric(5400),
                                   stdc=numeric(5400),
                                   avgv=numeric(5400), 
                                   stdv=numeric(5400))

# check the influence of seed, mtry, and ntree on the model
# account for the randomness in rF by running 100x for each param set
# so I didn't really think about this. Loop currently runs ~3-6 hours. 
# see RF MODEL DEVELOPMENT MANAGER
sd <- 1
k <- 1
while (sd < 101) {
  
  set.seed(sd)
  # subsample the training sets for each method
  rows.train.df <- sample(nrow(rFdata.cm3.df), 0.7*nrow(rFdata.cm3.df), replace=FALSE) # list of row vals only
  train.cm3.df <- rFdata.cm3.df[rows.train.df, ]
  valid.cm3.df <- rFdata.cm3.df[-rows.train.df, ]
  
  train.cm6.df <- rFdata.cm6.df[rows.train.df, ]
  valid.cm6.df <- rFdata.cm6.df[-rows.train.df, ]
  
  
  
  m=2
  while (m < 8) {
    
    n=500
    while (n < 2200) {
      
      i <- 1
      while (i < 2 ) {
        
        # normal models
        mod.cm3 <- randomForest(catm3 ~Drainage+
                                Tillage+
                                lulc.pothole+
                                lulc.field+
                                capa.ratio+
                                max.depth+
                                max.flow.path+
                                max.h2oshed.relief, data = train.cm3.df, ntree=n, mtry=m, replace=TRUE, importance=TRUE, proximity=TRUE)
        mod.cm3
        
        valid.cm3.df$pred <- predict2.randomForest(mod.cm3, valid.cm3.df)
        pred.cm3.err <- length(which(valid.cm3.df$pred != valid.cm3.df$catm3)) / length(valid.cm3.df$catm3)
        
        mod.cm6 <- randomForest(catm6 ~Drainage+
                                Tillage+
                                lulc.pothole+
                                lulc.field+
                                capa.ratio+
                                max.depth+
                                max.flow.path+
                                max.h2oshed.relief, data = train.cm6.df, ntree=n, mtry=m, replace=TRUE, importance=TRUE, proximity=TRUE)
        mod.cm6

        valid.cm6.df$pred <- predict2.randomForest(mod.cm6, valid.cm6.df)
        pred.cm6.err <- length(which(valid.cm6.df$pred != valid.cm6.df$catm6)) / length(valid.cm6.df$catm6)
        
        
        pct.var.cm3[i, 1] <- mod.cm3$err.rate[length(mod.cm3$err.rate[ ,1])]
        pct.var.cm3[i, 2] <- n
        pct.var.cm3[i, 3] <- m
        pct.var.cm3[i, 4] <- pred.cm3.err
        # pct.var.cm3[i, 5] <- mod.m$mse[length(mod.m$mse)]
        
        pct.var.cm6[i, 1] <- mod.cm6$err.rate[length(mod.cm6$err.rate[ ,1])]
        pct.var.cm6[i, 2] <- n
        pct.var.cm6[i, 3] <- m
        pct.var.cm6[i, 4] <- pred.cm6.err
        # pct.var.cm3[i, 5] <- mod.m$mse[length(mod.m$mse)]
        
        i = i+1
        
      }
      
      cm3.sensitivity.full[k, ] <- pct.var.cm3 %>%
        summarize(seed=mean(sd),
                  mtry=mean(m),
                  ntree=mean(n),
                  avgc=mean(err),
                  stdc=sd(err),
                  avgv=mean(valid.err), 
                  stdv=sd(valid.err))
      
      cm6.sensitivity.full[k, ] <- pct.var.cm6 %>%
        summarize(seed=mean(sd),
                  mtry=mean(m),
                  ntree=mean(n),
                  avgc=mean(err),
                  stdc=sd(err),
                  avgv=mean(valid.err), 
                  stdv=sd(valid.err))
      
      k <- k + 1
      n <- n + 200
      
    }
    m <-  m + 1
  }
  sd = sd + 1
  print(sd)
}

    # clean =============
    rm(train.cm3.df, train.cm6.df, train.m.df)
    rm(valid.m.df, valid.cm3.df, valid.cm6.df)
    rm(pct.var.m, pct.var.cm3, pct.var.cm6)
    rm(pred.cm3.err, pred.cm6.err, pred.m.rsq)
    




